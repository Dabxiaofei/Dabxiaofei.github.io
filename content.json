{"meta":{"title":"xffBlog","subtitle":"积跬步以至千里！","description":"所谓的成功，必须要学会努力","author":"xiaofei He","url":"http://xff6060.cn"},"pages":[{"title":"categories","date":"2018-03-16T06:18:43.000Z","updated":"2018-03-16T06:18:43.105Z","comments":true,"path":"categories/index-1.html","permalink":"http://xff6060.cn/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-14T11:51:24.000Z","updated":"2018-03-14T11:52:23.517Z","comments":true,"path":"categories/index.html","permalink":"http://xff6060.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-14T11:46:49.000Z","updated":"2018-03-14T11:48:08.116Z","comments":true,"path":"tags/index.html","permalink":"http://xff6060.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"几种美丽的分割线(html)","slug":"7193","date":"2018-07-19T03:59:04.000Z","updated":"2018-07-19T04:09:55.463Z","comments":true,"path":"2018/07/19/7193/","link":"","permalink":"http://xff6060.cn/2018/07/19/7193/","excerpt":"摘要:hr分割线","text":"摘要:hr分割线 几种美丽的分割线 一、普通 1、 &lt;HR&gt; 2、 &lt;HR align=center width=300 color=#987cb9 SIZE=1&gt; align 线条位置（可选left、right、center）；width 线条长度；color 颜色；size 厚度 二、特效（效果并不是孤立的，可相互组合） 1、两头渐变透明： &lt;HR style=&quot;FILTER: alpha(opacity=100,finishopacity=0,style=3)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=3&gt; 2、纺锤形： &lt;HR style=&quot;FILTER: alpha(opacity=100,finishopacity=0,style=2)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=10&gt; 3、右边渐变透明： &lt;HR style=&quot;FILTER: alpha(opacity=100,finishopacity=0,style=1)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=3&gt; 4、左边渐变透明： &lt;HR style=&quot;FILTER: alpha(opacity=0,finishopacity=100,style=1)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=3&gt; 5、虚线： &lt;HR style=&quot;border:1 dashed #987cb9&quot; width=&quot;80%&quot; color=#987cb9 SIZE=1&gt; 6、双线： &lt;HR style=&quot;border:3 double #987cb9&quot; width=&quot;80%&quot; color=#987cb9 SIZE=3&gt; 7、立体效果： &lt;HR style=&quot;FILTER: progid:DXImageTransform.Microsoft.Shadow(color:#987cb9,direction:145,strength:15)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=1&gt; 8、钢针效果： &lt;HR style=&quot;FILTER: progid:DXImageTransform.Microsoft.Glow(color=#987cb9,strength=10)&quot; width=&quot;80%&quot; color=#987cb9 SIZE=1&gt; ９．垂直分割线 &lt;table border=&quot;1px&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;height:265px;border-left-style:solid; border-bottom-style:none;border-right-style:none;border-top-style:none&quot;&gt;","categories":[{"name":"hr","slug":"hr","permalink":"http://xff6060.cn/categories/hr/"}],"tags":[{"name":"html","slug":"html","permalink":"http://xff6060.cn/tags/html/"}]},{"title":"Spring在代码中获取bean的几种方式","slug":"7192","date":"2018-07-19T03:09:28.000Z","updated":"2018-07-19T03:43:10.842Z","comments":true,"path":"2018/07/19/7192/","link":"","permalink":"http://xff6060.cn/2018/07/19/7192/","excerpt":"摘要:ssm框架学习","text":"摘要:ssm框架学习 在ssm中获取bean的几种方式 获取bean也就需要获取ApplicationContext 方法一：在初始化时保存ApplicationContext对象 //根目录ApplicationContext ac = new FileSystemXmlApplicationContext(“src/applicationContext.xml”);//src下ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);ac.getBean(“userService”);//比如： 方法二：通过Spring提供的utils类获取ApplicationContext对象 ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);ac1.getBean(“beanId”); 方法三：继承自抽象类ApplicationObjectSupport 调用getApplicationContext()方法。能够方便的获取ApplicationContext。 方法四：继承自抽象类WebApplicationObjectSupport 调用getWebApplicationContext()获取WebApplicationContext 方法五：实现接口ApplicationContextAware 实现setApplicationContext(ApplicationContext context)方法public void setApplicationContext(ApplicationContext applicationContext) { SpringContextUtil.applicationContext = applicationContext;} 方法六：通过Spring提供的ContextLoader WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext();wac.getBean(beanID);","categories":[{"name":"-ssm","slug":"ssm","permalink":"http://xff6060.cn/categories/ssm/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"Spring-@Aspect 的使用","slug":"7191","date":"2018-07-19T02:52:09.000Z","updated":"2018-07-19T03:08:19.678Z","comments":true,"path":"2018/07/19/7191/","link":"","permalink":"http://xff6060.cn/2018/07/19/7191/","excerpt":"摘要:ssm框架学习","text":"摘要:ssm框架学习 在ssm中AOP的使用xml中&lt;aop:aspectj-autoproxy /&gt; 引入AOP@Aspect加入到IOC容器@Component指向自定义注解路径@Pointcut(“@annotation(com.kxs.common.annotation.SysLog)”)/定义一个方法, 用于声明切入点表达式. 一般地, 该方法中再不需要添入其他的代码. 使用 @Pointcut 来声明切入点表达式. 后面的其他通知直接使用方法名来引用当前的切入点表达式. /@Pointcut(“execution(public int com.aop.ArithmeticCalculator.*(int, int))”) 前置通知 @Before（）返回通知@AfterReturning（）后置通知@After（）异常通知@AfterThrowing（）环绕通知：目标方法执行前后分别执行一些代码，发生异常的时候执行另外一些代码@Around（）括号内容value=”execution( com.qcc.beans.aop..*(..))” @Before 比方：拦截service方法 1.Before 在执行service方法之前，触发该方法 2.After在执行service方法之后，触发该方法 3.AfterThowing 在执行Service时抛出异常触发 4.Around回绕通知，在之前，之后都会触发 用法 @Before(value = “execution ( com.service.impl..*(..))”)","categories":[{"name":"-ssm","slug":"ssm","permalink":"http://xff6060.cn/categories/ssm/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"javaWeb03","slug":"4103","date":"2018-04-01T14:56:53.000Z","updated":"2018-07-19T03:34:54.517Z","comments":true,"path":"2018/04/01/4103/","link":"","permalink":"http://xff6060.cn/2018/04/01/4103/","excerpt":"摘要:java学习","text":"摘要:java学习 在java中如何访问jsp的内置对象public class MyFunction { public void addEmp(HttpServletRequest request) { String empno =request.getParameter(“empno”); System.out.println(“参数~~~~”+empno); }}在jsp中&lt;%MyFunction mf = new MyFunction();mf.addEmp(request);%&gt;当我们进行访问http://localhost:8080/WebDemo03/JspTojava.jsp?empno=31我们MyFunction就能进行响应获得内容登陆注册包含了有什么功能注册1、验证码2、发送手机校验3、绑定邮箱 点击邮箱进行激活登陆第三方登陆 QQ微信找回密码单点登陆 什么是单点登陆，就是当前有一个点进行登陆，忽略其他异常情况，只考虑校验用户名和密码 public class LoginUtil { public static void main(String[] args) throws Exception { boolean is = LoginUtil.verify(“zhangcheng”, “qaz1”); if (is) { System.out.println(“登陆成功”); }else { System.out.println(“登陆失败”); }} public static boolean verify(String username,String password) throws Exception { Connection con = null; ResultSet rs =null; PreparedStatement stm = null; String sql = “select * from users where username=? and password=? and status=1”; Class.forName(“com.mysql.jdbc.Driver”); String url = “jdbc:mysql://localhost:3306/javaweb?useUnicode=true&amp;characterEncoding=utf-8”; String sqlusername = “root”; String sqlpassword = “pwd”; con = DriverManager.getConnection(url,sqlusername,sqlpassword); stm = con.prepareStatement(sql); stm.setString(1, username); stm.setString(2, password); rs=stm.executeQuery(); boolean isSuccess=true; if (rs.next()) { isSuccess = true; }else { isSuccess = false; } //释放资源 rs.close(); stm.close(); con.close(); return isSuccess; }} &lt;%//用于显示错误信息String error = (String)request.getAttribute(“error”);if(error!=null){ out.println(error);}%&gt; 用户名:密码: Cookie刚才我们说到了登陆，登陆以后我们如何保存登陆的数据，session可以进行保存，但是session保存时候，是保存当次的会话，我们关闭了浏览器，下次是否还需要再次进行登陆？cookie解决这个问题 Cookie是什么Cookie是一小段的文本信息，Web服务器将它发送到浏览器客户端，以文本形式保存起来，随后当浏览器下次访问该站点的时候，Web服务器可以通过Cookie来获得到上次访问的记录Cookie存储的方式一般是一个属性和一个值的形式Cookie数据存在磁盘上，电脑关闭后仍然存在当你下次在访问该站点时候，我读取cookie就可以进行免登陆 Cookie的用法回到我们的loginWebDemo项目，我们通过Cookie来保存用户名和密码 添加cookie&lt;%//创建一个cookieCookie c1 = new Cookie(“username”,”zhangcheng”);//设置cookie的有效期c1.setMaxAge(6060247);Cookie c2 = new Cookie(“password”,”qaz”);c2.setMaxAge(6060247); response.addCookie(c1);response.addCookie(c2);//setMaxAge 方法参数为0的时候，表示命令浏览器立即删除cookie 参数为-1时候，永久保存%&gt; 读取cookie{ &lt;%out.println(“所有cookie：“);Cookie[] c= request.getCookies(); if(c!=null&amp;&amp;c.length&gt;0){ for(int i=0;i&lt;c.length;i++){ out.println(c[i].getName()+”=”+c[i].getValue()); out.println(““); }} 完善login内容登陆成功后写入cookie，下次登陆自动填充&lt;%Cookie[] c= request.getCookies(); String username=null;String password=null; if(c!=null&amp;&amp;c.length&gt;0){ for(int i=0;i&lt;c.length;i++){ if(c[i].getName()!=null&amp;&amp;c[i].getName().equals(&quot;username&quot;)){ username = c[i].getValue(); } if(c[i].getName()!=null&amp;&amp;c[i].getName().equals(&quot;password&quot;)){ password = c[i].getValue(); } } if(username==null){ username =&quot;&quot;; } if(password==null){ password =&quot;&quot;; } } 用户名:密码: &lt;%request.setCharacterEncoding(“UTF-8”);String username = request.getParameter(“username”);String password = request.getParameter(“password”);if(LoginUtil.verify(username, password)){ out.println(“即将进入主页”); Cookie c1 = new Cookie(“username”,username); Cookie c2 = new Cookie(“password”,password); response.addCookie(c1); response.addCookie(c2);}else{ request.setAttribute(“error”, “登陆失败！用户无效“); request.getRequestDispatcher(“Login.jsp”).forward(request, response);}%&gt;","categories":[{"name":"复习","slug":"复习","permalink":"http://xff6060.cn/categories/复习/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"javaWeb02","slug":"4102","date":"2018-04-01T14:28:59.000Z","updated":"2018-07-19T03:34:47.306Z","comments":true,"path":"2018/04/01/4102/","link":"","permalink":"http://xff6060.cn/2018/04/01/4102/","excerpt":"摘要:java学习","text":"摘要:java学习 jsp中内置对象request内置对象 web服务器收到客户端的http请求，会针对每一次请求，分别创建一个代表请求的request对象，和代表响应的response对象request和response对象表示请求和响应，那我们要获得客户机提交过来数据，只需要request对象就可以，要向客户机输出数据，只需要response对象就行了request 是HttpServletRequest类型是用于接收用户需求的一个请求体 跳转与转发redirect方式跳转&lt;%//进行跳转//response.sendRedirect(“RedirectAction.jsp?name=zhangcheng”);//跳转站外连接response.sendRedirect(“http://www.baidu.com&quot;);//以上有什么好处，直接可以跳转站外连接，但是地址栏也会跟随变化%&gt;forward方式跳转&lt;%request.setAttribute(“name”, “zhangcheng”);RequestDispatcher dispatcher = request.getRequestDispatcher(“RedirectAction.jsp”);dispatcher.forward(request, response);//以上有什么好处，地址栏不会变化，但是无法跳出站外，只能在站内跳转//但是forward跳转方式会把上一个页面的request对象带到跳转后的页面，也就是跳转前和跳转后页面公用一个request对象，根据这个原理，我们如果在跳转页面前向request存储数据，那么跳转后的页面可以从request中取得这些数据%&gt;二种跳转方式的区别URL的变化redirect跳转后浏览器URL地址栏显示的是跳转后的地址forward跳转后浏览器URL显示的还是当前地址，没有发生变化速度上区别redirect是在客户端上跳转，速度慢forward跳转是在服务器上跳转，速度快在对象区别redirect跳转，上一页和跳转后的页面不共享同一个requestforward跳转，上一个页面和跳转后的页面共享同一个request对象共享的同一个request对象，则可以使用这个对象进行传值写入数据Response内置对象1、页面跳转redirect方式跳转，使用sendRedirect方式，可以实现页面跳转//response.sendRedirect(“RedirectAction.jsp?name=zhangcheng”);2、页面打印&lt;%String n = request.getParameter(“name”);out.print(“getParameter “+n+”“);String s = (String)request.getAttribute(“name”);out.print(“att “+s+”“);response.getWriter().println(“HELLO”);%&gt;输出是在最后输出的，但是显示页面内容，会最先输出HttpSession内置对象1、Session作用对于某个用户来说，一个全局的数据容器，一个用户有一个Session，不同用户有不同Session，Session中可以存放数据我们经常使用Session在多个不同的页面之间共享数据具体应用场景当用户登陆之后，把用户信息存放在Session中，然后其他页面可以从Seesion中取出用户信息来显示，如果其他页面从Seesion中没有取到用户信息，说明这个用户没有登陆&lt;%session.setAttribute(“myname”, “zhangcheng”);%&gt;要读取的地方进行获取内容//根据session获得mynameString n1=(String)session.getAttribute(“myname”);out.print(“session “+n1);Application内置对象&lt;%//application像是公告栏，针对所有用户有效，在这里存储数据，所有用户都可以获取application.setAttribute(“application”, “test”);%&gt;String a = (String)application.getAttribute(“application”);out.print(“application “+a);Jsp中如何定义函数 获取当前时间的函数&lt;%!//定义函数public String getCurrentTime(){ Date d = new Date(); DateFormat df = new SimpleDateFormat(“YYYY-MM-dd HH:mm:ss”); String strTime = df.format(d); return strTime;}%&gt;&lt;%//调用函数String s= getCurrentTime();out.println(“当前系统时间”+s);%&gt; 使用数据库动态创建我们的选择项目 &lt;%!public ArrayListqueryAllDept()throws Exception{ //需要添加mysql驱动包 Class.forName(“com.mysql.jdbc.Driver”); //连接数据库 String url=”jdbc:mysql://localhost:3306/javaweb?useUnicode=true&amp;characterEncoding=utf-8”; String username = “root”; String password = “pwd”; Connection con = DriverManager.getConnection(url,username,password); String sql=”select * from dept”; Statement stm = con.createStatement(); ResultSet rs = stm.executeQuery(sql); ArrayList deptlist = new ArrayList&lt;&gt;(); while(rs.next()){ int dno =rs.getInt(1); String dname = rs.getString(2); String deptInfo = dno+”,”+dname; deptlist.add(deptInfo); } rs.close(); stm.close(); return deptlist;}%&gt;调用 &lt;%ArrayListlist = queryAllDept();if(list!=null&amp;&amp; list.size()&gt;0){ for(int i=0;i&lt;list.size();i++){ String dinfo = (String)list.get(i); String dno = dinfo.split(“,”)[0]; String dname = dinfo.split(“,”)[1]; out.println(““+dname+”“); }}%&gt; jsp对数据库的增删改查的操作进行增加操作 员工编号：员工姓名： 响应页&lt;%//设置格式内容request.setCharacterEncoding(“utf-8”);%&gt;&lt;%//获得表单提交数据String empno=request.getParameter(“empno”);String empname=request.getParameter(“empname”);Class.forName(“com.mysql.jdbc.Driver”);//连接数据库String url=”jdbc:mysql://localhost:3306/javaweb?useUnicode=true&amp;characterEncoding=utf-8”;String username = “root”;String password = “xxxx”;Connection con = DriverManager.getConnection(url,username,password);//输出页面内容 out.println(empno+””+empname); String sql=”insert into EMP(empno,ename)values(?,?)”; PreparedStatement ps = con.prepareStatement(sql); ps.setString(1, empno); ps.setString(2,empname); ps.execute(); ps.close(); con.close(); out.println(“添加成功”);%&gt;","categories":[{"name":"复习","slug":"复习","permalink":"http://xff6060.cn/categories/复习/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"javaWeb01（jsp入门）","slug":"4101","date":"2018-04-01T13:30:01.000Z","updated":"2018-07-19T03:34:41.827Z","comments":true,"path":"2018/04/01/4101/","link":"","permalink":"http://xff6060.cn/2018/04/01/4101/","excerpt":"摘要:java学习","text":"摘要:java学习 环境搭建1、安装tomcat，可以进行启动，但是注意和我们的Eclipse关联时候，需要手动关闭，因为会与我们Eclipse配置的端口冲突2、创建javaweb工程的时候，serverruntime进行配置时候，可能会出错，导致servlet-api找不到3、如何解决 1.在tomcatlib下找到servlet-api的jar包，添加到我们的工程目录的WEB-INF下的lib目录下 2.使用自动加载，伴随jdk进行加载首先找到jdk安装位置找到jre文件夹，在jre文件夹下的ext文件夹下，添加servlet-api的jar包，如果jre没有自动加载，手动添加进入即可，一次添加以后无需添加创建jspjsp是创建在WebContent不能创建在META-INF或者WEB-INF文件夹下，如果创建在这2个文件夹下，直接会导致外部不能直接进行访问我们在最开始创建的JSP中，会发现和我们的html没有任何不一样jsp和html具体有什么区别呢？jsp实现原理是是基于Servlet基础上进行实现的，主要用于展示页面内容，jsp里面可以插入java代码一、如何插入java代码我们通过 &lt;%%&gt; 在二个%中间写相应的java代码 二、如何输出语句 &lt;%//输出到控制台System.out.println(“输出内容”);//输出到前台页面上out.println(“hello World “);%&gt;System.out.println还是输出到控制台out是直接向jsp上直接输出，并且支持html标签 需要注意的是如果输出中文，会乱码，需要修改相应的编码为utf-8 三、项目发布和Eclipse直接调用原理 项目的发布，是直接通过web工程打包为war包，放入到webapps下，tomcat会自动进行解压，项目就完成了发布 而Eclipse能直接控制tomcat，原理也是采用你修改了代码，就进行同步里面的内容，是所有内容同步还是部分内容同步？我们通过在里面访问一张照片，检验出，是所有进行文件夹覆盖打印变量如果直接输出值&lt;%=8%&gt;输出变量&lt;%//声明变量String s=”hello world”;out.println(s);%&gt;&lt;%=s%&gt; form表单1、单行数据 单行数据显示员工编号:员工姓名: 响应页面&lt;%String s = request.getParameter(“empnum”);String s1 = request.getParameter(“empname”);%&gt;&lt;%=”员工编号 “+s%&gt;&lt;%=”员工姓名”+s1%&gt; 2、多行数据获得多行文本数据文章内容响应页面String s2 = request.getParameter(“textarea的name”);&lt;%=”文章内容”+s2%&gt;在这里提交中文会出现乱码request.setCharacterEncoding(“utf-8”);3、下拉框选中的数据 下拉框选中内容部门: 人力资源部 开发部 广告部 行政部 响应页处理String s3 = request.getParameter(“select下拉框的name”);&lt;%=”部门”+s3%&gt; 4、获得单选框内容 男 女响应页String s4 = request.getParameter(“单选框的name”);&lt;%=”性别”+s4%&gt; 5、获得复选框数据 打球 游戏 游泳 跑步响应页&lt;%//防止不选择就提交if(s5!=null&amp;&amp;s5.length&gt;0){ for(int i=0;i&lt;s5.length;i++){ out.println(“多选数据 “+s5[i]); }}%&gt;6、多个同名输入框 响应页String[] s6 = request.getParameterValues(“username”); &lt;%//防止不选择就提交if(s6!=null&amp;&amp;s6.length&gt;0){for(int i=0;i&lt;s6.length;i++){ out.println(“同名输入框 “+s6[i]); }}%&gt; 总结 单行文本、多行文本、下拉框，单选框，这几种输入框，后台获得输入框中的数据，都是一样String s3 = request.getParameter(“输入框的name”);复选框由于可以多选，选中的选项形成一个数组，所有后台获得复选框选中值，需要使用数组进行保存String[] s6 = request.getParameterValues(“username”);需要注意的是，数组进行保存，如果用户没有选择，就进行提交，我们在接收数据，应当进行判断，否则会导致程序崩溃 中文乱码的问题request.setCharacterEncoding(“utf-8”);","categories":[{"name":"复习","slug":"复习","permalink":"http://xff6060.cn/categories/复习/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"技术这东西","slug":"2902","date":"2018-03-29T08:13:57.000Z","updated":"2018-03-29T08:58:54.648Z","comments":true,"path":"2018/03/29/2902/","link":"","permalink":"http://xff6060.cn/2018/03/29/2902/","excerpt":"摘要:技术成长","text":"摘要:技术成长技术这东西，要想提高的话，说来说去，其实就是理论、实践加总结。 理论的话，可以看书，可以从网络上获取信息。实践的话，则一般是在工作当中，或者自己平日里写写开源项目。 至于总结，最好的办法，自然是写博客。 掌握这三个步骤，几乎任何东西，你都可以按部就班的学会，只要你愿意付出时间和精力。 成功，则意味着坚持。 好了，今天的牛逼吹完了，吃鸡去了。","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://xff6060.cn/tags/博客/"}]},{"title":"聊天喽","slug":"2901","date":"2018-03-29T07:34:01.000Z","updated":"2018-03-29T07:46:26.252Z","comments":true,"path":"2018/03/29/2901/","link":"","permalink":"http://xff6060.cn/2018/03/29/2901/","excerpt":"摘要:聊天记录","text":"摘要:聊天记录{\\__/}( • - •)/つ 寿司要不要? {\\__/}( • - •)/つ 草莓要不要? {\\__/}( • - •)/つ🍕 披萨要不要? {\\__/}( • - •)/つ🍑 桃子要不要? {\\__/}( • - •)/つ 我你要不要?","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"聊天","slug":"聊天","permalink":"http://xff6060.cn/tags/聊天/"}]},{"title":"java二叉树","slug":"1901","date":"2018-03-19T01:22:04.000Z","updated":"2018-03-19T02:51:43.698Z","comments":true,"path":"2018/03/19/1901/","link":"","permalink":"http://xff6060.cn/2018/03/19/1901/","excerpt":"摘要:数据结构","text":"摘要:数据结构今天练习用java实现二叉树的遍历算法，首先我先编写二叉树类BinaryTree，代码如下：package package2;public class BinaryTree { int data; //根节点数据 BinaryTree left; //左子树 BinaryTree right; //右子树 public BinaryTree(int data) //实例化二叉树类 { this.data = data; left = null; right = null; } public void insert(BinaryTree root,int data){ //向二叉树中插入子节点 if(data&gt;root.data) //二叉树的左节点都比根节点小 { if(root.right==null){ root.right = new BinaryTree(data); }else{ this.insert(root.right, data); } }else{ //二叉树的右节点都比根节点大 if(root.left==null){ root.left = new BinaryTree(data); }else{ this.insert(root.left, data); } } }}当建立好二叉树类后可以创建二叉树实例，并实现二叉树的先根遍历，中根遍历，后根遍历，代码如下：package package2;public class BinaryTreePreorder { public static void preOrder(BinaryTree root){ //先根遍历 if(root!=null){ System.out.print(root.data+”-“); preOrder(root.left); preOrder(root.right); } } public static void inOrder(BinaryTree root){ //中根遍历 if(root!=null){ inOrder(root.left); System.out.print(root.data+”–”); inOrder(root.right); } } public static void postOrder(BinaryTree root){ //后根遍历 if(root!=null){ postOrder(root.left); postOrder(root.right); System.out.print(root.data+”—“); } } public static void main(String[] str){ int[] array = {12,76,35,22,16,48,90,46,9,40}; BinaryTree root = new BinaryTree(array[0]); //创建二叉树 for(int i=1;i&lt;array.length;i++){ root.insert(root, array[i]); //向二叉树中插入数据 } System.out.println(“先根遍历：”); preOrder(root); System.out.println(); System.out.println(“中根遍历：”); inOrder(root); System.out.println(); System.out.println(“后根遍历：”); postOrder(root); 创建好的二叉树图形如下: 当运行上面的程序后结果如下：先根遍历：12-9-76-35-22-16-48-46-40-90-中根遍历：9–12–16–22–35–40–46–48–76–90–后根遍历：9—16—22—40—46—48—35—90—76—12—","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"接口","slug":"1202","date":"2018-03-16T04:02:57.000Z","updated":"2018-03-19T02:51:43.673Z","comments":true,"path":"2018/03/16/1202/","link":"","permalink":"http://xff6060.cn/2018/03/16/1202/","excerpt":"摘要:java编程思想","text":"摘要:java编程思想 接口抽象类的方法默认为抽象接口可以继承接口接口中的域隐式地是static和final的接口可以嵌套在其他类和接口中当实现某个接口时，并不需要实现嵌套在其内部的任何接口使用接口的时候，要注重的是重构，而不是增加接口。","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"java","slug":"java","permalink":"http://xff6060.cn/tags/java/"}]},{"title":"实现点击出现桃心效果","slug":"1130","date":"2018-03-16T03:30:39.000Z","updated":"2018-03-16T06:06:14.742Z","comments":true,"path":"2018/03/16/1130/","link":"","permalink":"http://xff6060.cn/2018/03/16/1130/","excerpt":"摘要:优化博客之路","text":"摘要:优化博客之路 具体实现方法在网址输入如下http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\\themes\\next\\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://xff6060.cn/tags/hexo/"}]},{"title":"一天建立写出博客","slug":"1505","date":"2018-03-15T12:40:22.000Z","updated":"2018-03-29T08:11:38.669Z","comments":true,"path":"2018/03/15/1505/","link":"","permalink":"http://xff6060.cn/2018/03/15/1505/","excerpt":"摘要:1天建立博客的路程","text":"摘要:1天建立博客的路程 从开始想建立博客，以及过去好久了，这么长的时间中，一直在断断续续向前走开始的时候，想用ssm框架来写的，可惜，需要买一个服务器，就一直没动手后来，因为公司用的是jfinal，就想用jfinal写出来的，顺带也就当学习了，还是不了了之某天看到一群前端大神写的html，真的漂亮，就花了一天时间，把各种各种的好看页面都放上去了然后，就一直完成工作了，那就是去学习android知道昨天，我的工作完成之后，突然发现了一个博客，用的是hexo写出来的，好久之前的想法涌上心头。我就查了一下资料，发现都在说这个框架的简便。既然大家都说简单了，那就试试呗，哈哈，经过，12个小时的艰苦奋斗，终于完成了大部分的功能。还有几处有bug，今天还没解决1、搜索功能2、上传后两张图片显示不出来3、图标的问题，就是出不来4、宠物的显示，出不来5、网易云音乐没时间搞了6、文章评论功能大概就这些了，现在已经将近晚上9点了，还没吃晚饭，好饿，我要去吃饭了。","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://xff6060.cn/tags/hexo/"}]},{"title":"如何卖仓","slug":"如何编写博客","date":"2018-03-15T01:28:24.000Z","updated":"2018-03-16T06:07:02.226Z","comments":true,"path":"2018/03/15/如何编写博客/","link":"","permalink":"http://xff6060.cn/2018/03/15/如何编写博客/","excerpt":"摘要:生活不止眼前的苟且，还有日后的苟且。","text":"摘要:生活不止眼前的苟且，还有日后的苟且。 1． 生存法则: 由开仓原则、短期原则、最大风险额度三项原则组成；保障资本的安全是投资最核心的法则！这是所有投资法则和投资策略的基石。身为职业投资管理者，最低程度为了今后10年的长期平稳发展和生存，减少风险、回避风险、控制风险是重中之重！2． 最大风险额度原则：任何一笔交易最大亏损都不得高于资产的5％,是生存法则的最后一层防护墙。无法控制损失的，风险/报酬比过高的交易就是不当交易，想稳定发展就必须避免――不当交易。亏不起，经不起任何意外的打击，出局了就什么都没了！ 3． 不做任何没设止损的交易。到了止损就习惯的严守纪律能立即了结头寸。交易没设止损就如同战场上没穿防弹衣，灾难临头将导致生活会突然中止，正确的习惯止损是成熟的首要，将挽救你的金融生涯. 4． 耐心，基本功之一，放弃该放弃的，把握能把握的；只坚持做符自己投资标准的投资，简以致胜，以简单应对复杂，把握中期时间框架,具有无限等待的耐心！舍弃不合要求的赌局，可以很轻松的对能力以外的机会说“不”。市场存在风险有限而获利空间巨大的战略机遇！没有胜率不出手。从长期看，良好的耐心终会获得丰厚的回报！ 耐心――趋势不变，持仓不变！坚定的拿住持仓！！","categories":[{"name":"经济学","slug":"经济学","permalink":"http://xff6060.cn/categories/经济学/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://xff6060.cn/tags/读书/"}]},{"title":"多态","slug":"hello","date":"2018-03-15T01:21:22.000Z","updated":"2018-03-29T08:11:34.181Z","comments":true,"path":"2018/03/15/hello/","link":"","permalink":"http://xff6060.cn/2018/03/15/hello/","excerpt":"摘要:java编程思想","text":"摘要:java编程思想多态作用：消除类型之间的耦合关系父类可以使用子类覆写自己的方法，在父类使用private，final时，子类不能继承。通过的是向上转型的方法。java除了static和final方法之外，都属于后期绑定。初始化顺序：1、基类构造类2、成员初始化方法3、类构造器方法private方法默认属final","categories":[{"name":"成长","slug":"成长","permalink":"http://xff6060.cn/categories/成长/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://xff6060.cn/tags/读书/"}]}]}